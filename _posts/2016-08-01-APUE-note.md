### 目录项

目录（directory）是一个包含目录项的文件。逻辑上可以认为每个目录项包含一个文件名，和说明该文件属性的信息。

目录项的逻辑视图与实际存放在磁盘上的方式是不同的。UNIX文件系统的大多数实现并不在目录项中存放属性，这是因为一个文件具有多个硬链接时，很难保持多个属性副本之间的同步。

### 信号

信号（signal）用于通知进程发生了某种情况。

键盘上通过中断键（interrupt key，通常是Delete或Ctrl+C）和退出键（quit key，通常是Ctrl+\\）中断当前运行进程。

也可以调用kill()函数，向另一个进程发送信号。但是必须是该进程的所有者或者超级用户。

进程有3中处理信号的方式：
1. 忽略，不推荐
2. 按系统默认方式处理
3. 提供自编函数，捕捉并处理该信号

### 时钟时间、用户CPU、系统CPU

时钟时间：进程从开始运行到结束，时钟走过的时间，包括进程在阻塞和等待状态的时间

用户CPU时间：进程执行用户指令所用的时间

系统CPU时间：进程执行内核指令所用的时间

```
$ time  ./a.out

real    0m4.019s           //时钟时间
user    0m0.004s           //用户CPU时间
sys     0m0.000s           //系统CPU时间
```

### 关于第三章“不带缓冲的I/O的意思”

所有磁盘I/O都要经过内核的块缓存区，所有read write的数据也会被内核缓存。这里说read write是“不带缓冲的I/O”指的是用户进程不对两个函数自动缓冲，每次都要进行系统调用。

对 图3-6 Linux上用不同缓冲长度进行read操作的时间结果 说明
1. 当BUFFSIZE为1-32时，需要进行频繁的系统调用，所以用户CPU时间、系统CPU时间、时钟时间都比较大。
2. 当BUFFSIZE大于32时，时钟时间主要受磁盘I/O影响，由于大多数文件系统对磁盘I/O进行内核块缓存区，所以磁盘I/O的次数大致一样，时钟时间大致一样。

对 图5-6 使用标准I/O例程（fgets/fputs/getc/putc/fgetc/fputc）得到的实验结果 说明
1. 都比3-6最佳read版差，原因是循环次数大，fgets每次读一行、getc每次读一个字符。
2. 比3-6单字节read版好几十倍，标准I/O在用户进程内使用缓冲区。每次陷入内核read，不仅仅读取一行或者一个字节。
3. 系统CPU时间几乎相同，说明陷入内核态的次数及磁盘读写的次数几乎相同。用户缓冲区使得进程不用频繁陷入内核，内核缓冲区使得read调用不用频繁做磁盘I/O。

**总结**

内核块缓存区：减少read/write系统调用进行磁盘I/O的次数。

用户缓冲区：减少读取数据时进行系统调用的次数。

### 追加标志O_APPEND对文件读写的影响

1. 仍然可以使用lseek和read函数读文件中任意一个位置的内容
2. write函数在写数据之前会自动将文件偏移量设置为文件尾，所以写文件时只能在文件尾端开始。

### 文件模式字：设置用户ID位、设置组ID位

当执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID通常就是实际组ID，但是
1. 设置了set-user-ID位时，进程的有效用户ID为程序文件的所有者的用户ID
2. 设置了set-group-ID位时，进程的有效组ID为程序文件的组所有者ID

设置用户ID位、设置组ID位 都包含在stat.st_mode值中。可分别用常量S_ISUID/S_ISGID测试。

### 新文件和目录的所有权

新文件和目录的所有权规则一样。

1. 新文件的用户ID设置位进程的有效用户ID。
2. 新文件的组ID可以是
 - 进程的有效组ID
 - 新文件所在目录的组ID

组ID的设置规则：FreeBSD 8.0和Mac OS X 10.6.8默认使用新文件所在组的ID；Linux和Solaris需要检查新文件所在目录的设置组ID位，如果该目录的这一位被设置，则新文件的组ID设置为目录的组ID。

### 文件访问权限检查

open函数打开一个文件时，内核按进程的有效用户ID和有效组ID为基础执行访问权限测试

access和faccessat函数是按实际用户ID和实际组ID进行访问权限测试

访问权限测试步骤，access函数将有效ID换成实际ID来测试：
1. 若进程的有效用户ID为0（超级用户），则允许
2. 若进程的有效用户ID等于文件的所有者ID，那么如果所有者适当的访问权限位被设置，则允许
3. 若进程的有效组ID或者附属组ID之一等于文件的组ID，那么如果组适当的访问权限位被设置，则允许
4. 若其他用户适当的访问权限位被设置，则允许

### 文件系统

马丹，比哪个博客说的都清楚。P91，4.14节的图很清楚。

磁盘：    |分区|分区|分区|分区|...
分区：    |自举块|超级块|柱面组|柱面组|柱面组|...
柱面组：   |超级块副本|配置信息|i节点图|块位图|i节点数组|数据块|
i节点数组：|i节点|i节点|i节点|i节点|...
数据块：   ...|数据块|...|目录块|...
目录块：   |.|..|目录项|...
目录项：   |i节点编号ino_t|文件名|

1. i节点中都有一个链接计数，其值是指向该i节点的目录项数。当链接数为0时，才会释放数据块
2. i节点包含文件相关的所有内容。文件类型、文件访问权限位、文件长度和指向文件数据块的指针等。
3. 目录项只存放两项重要数据：i节点编号、文件名
4. 目录项中的i节点编号只能指向同以文件系统中的i节点。所以ln(1)命令不能跨越文件系统
5. 符号链接文件的实际内容（在数据块中）包含了该符号链接所指向的文件的名字。该文件名字可以跨文件系统
6. 在不改变文件系统的情况下对一个文件进行重命名，不会移动文件的实际内容，仅创建新的指向现在i节点的目录项，删除旧的目录项。

## 以下章节先跳过

### 7 进程环境

### C语言中全局变量、局部变量、静态全局变量、静态局部变量比较

C++的作用域：全局作用域、局部作用局、语句作用域、类作用域、命名空间作用域、文件作用域
1. 全局变量具有全局作用域，只需在一个源文件中定义，就可以作用于所有源文件。
2. 静态全局变量也具有全局作用域，与全局变量的区别在于如果包含多个文件的话，它作用于定义它的文件里。
3. 静态局部变量具有局部作用域，只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，只对定义自己的函数体始终可见。
4. 局部变量页只有局部作用域，它是自动对象（auto），在程序运行期间不是一直存在的，函数一次调用执行结束后，就被撤销，所占用内存也被回收。

从分配内存空间看：
1. 全局变量、静态局部变量、静态全局变量都在静态存储区分配空间
2. 而局部变量在栈里分配空间

### 8 进程控制
### 9 进程关系
### 10 信号

进程捕捉到信号并对其进行处理时，进程所执行的正常指令序列就被信号处理函数临时中断，它首先执行该信号处理程序中的指令。如果从信号处理程序返回（例如没有调用exit或longjmp），则继续执行在捕捉到信号时正在执行的正常指令序列（这类似于发生硬件中断时所做的）。

### 11 线程
### 12 线程控制
### 13 守护进程
### 14 高级I/O

1. 非阻塞I/O
2. 记录锁
3. I/O多路转接——select和poll函数
4. 异步I/O（aio_read/aio_write...）
5. readv和writev函数
6. 存储映射I/O（mmmap）

### 15 进程间通信

管道

函数popen和pclose

FIFO

#### XSI IPC

> 每个内核中的IPC结构都用一个非负整数的标识符（identifier）加以引用
> 标识符是IPC对象的内部名，对象的外部名为一个键（key_t 被定义为长整型）

##### 消息队列

> 消息队列是消息的链接表，存储在内核中，由消息队列标识符标识。

操作流程：
1. msgget()创建一个新队列，或者引用一个现有队列
2. msgctl()获取、修改队列状态信息、删除队列
3. msgsnd()将任意类型的消息发送到消息队列尾端，消息都有自己的type字段
4. msgrcv()得到第一个消息/得到第一个该类型的消息等

```c
/**
 * 每个队列都有个这个结构，记录消息队列的信息
 */
struct msqid_ds {
  struct ipc_perm msg_perm;   //有效用户、组ID，访问权限等
  msgqnum_t       msg_qnum;   //队列中消息数
  msglen_t        msg_qbytes; //能使用的最大字节数
  pid_t           msg_lspid;  //last send pid
  pid_t           msg_lrpid;  //last rcv pid
  time_t          msg_stime;  //last send time
  time_t          msg_rtime;  //last rcv time
  time_t          msg_ctime;  //last change time
  ...
};

#include <sys/msg.h>

/**
 * 打开一个现有队列，或创建新队列
 * @key   消息队列的外部键名
 * @flag  消息队列的ipc-perm.mode的权限位
 * return 消息队列的内部标识符
*/
int msgget(key_t key, int flag);

/**
 * 对队列进行操作的函数
 * @msqid 消息队列的内部标识符
 * @cmd   IPC_STAT  获取此队列的msqid_ds结构，并放到buf中
 *        IPC_SET   从buf中设置msg_perm.uid/msg_perm.gid/msg_perm.mode/msg_pbytes
 *        IPC_RMID  从系统中删除该消息队列，及其中的所有数据
 * return 若成功 返回0；否则 返回-1
*/
int msgctl(int msqid, int cmd, struct msqid_ds *buf);

/**
 * 将数据放到消息队列尾端：成功时更新msgid_ds结构的msg_lrpid/msg_rtime/msg_qnum+1
 * @msqid 消息队列的内部标识符
 * @ptr   待存放的数据：类型字段、非负的长度、实际的数据
 * @nbytes数据的长度
 * @flag  可以设为非阻塞：IPC_NOWAIT
 * return 若成功 返回0；否则 返回-1
*/
int msgsnd(int msqid, const void *ptr, size_t nbytes, int flag);

/**
 * 一个可能的消息结构，即ptr指向的对象
*/
struct mymesg {
  long mtype;       // positive message type
  char mtext[512];  // message data, of length nbytes
}

/**
 * 从队列中取用消息：成功时更新msgid_ds结构的msg_lrpid/msg_rtime/msg_qnum-1
 * @msqid 消息队列的内部标识符
 * @ptr   待存放的数据：类型字段、非负的长度、实际的数据
 * @nbytes数据的长度
 * @type  =0 返回队列中第一个消息
          >0 返回队列中消息类型为type的第一个消息
          <0 返回队列中消息类型值小于等于type，且类型值最小的那个消息
 * @flag  可以设为非阻塞：IPC_NOWAIT
 * return 若成功 返回0；否则 返回-1
*/
int msgrcv(int msqid, void *ptr, size_t nbytes, long type, int flag);

```

apue的最后结论是，不推荐再使用消息队列了，原因就是IPC存在的一些缺陷
1. 系统范围内起作用，且没有引用计数，删除是个问题
2. IPC结构在文件系统中没有名字，不得不增加新的系统调用
3. 不使用文件描述符，所以不能使用多路转接函数，有些功能就实现不了。

##### 信号量

> 信号量跟其他的IPC机构（管道、FIFO以及消息队列）不同，它是一个计数器，用于为多个进程提供对共享数据对象的访问

操作流程：
1. semget()创建含有nsems个信号量的信号量集，或者引用现有信号量集
2. semctl()初始化各个信号量值，获得、修改信号量集状态、删除信号量集
3. semop()原子地增加、减少信号量

```c
/**
 * 同样的，信号量也有一个维护信息的结构
 */
struct semid_ds {
  struct ipc_perm sem_perm;   //有效用户、组ID，访问权限等
  unsigned short  sem_nsems;  //信号量集合的大小
  time_t          sem_otime;  //last-semop time
  time_t          sem_ctime;  //last-change time
  ...
};

struct {
  unsigned short  semval;   // semaphore value, always >= 0
  pid_t           sempid;   // pid for last operation
  unsigned short  semncnt;  // num of processes awaiting semval > curval
  unsigned short  semzcnt;  // num of processes awaiting semval == 0
  ...
}

#include <sys/sem.h>

/**
 * 打开一个现有信号量集合，或创建新信号量集合
 * @key   信号量集合的外部键名
 * @nsems 信号量集合的大小
 * @flag  信号量集合的ipc-perm.mode的权限位
 * return 信号量集合的内部标识符
*/
int semget(key_t key, int nsems, int flag);

/**
 * 对信号量集合进行操作
 * @semid 信号量集合的内部标识符
 * @semnum指向该信号量集合中的一个成员
 * @cmd   IPC_STAT  获取此队列的semid_ds结构，并放到buf中
 *        IPC_SET   从arr.buf中设置sem_perm.uid/sem_perm.gid/sem_perm.mode
 *        IPC_RMID  从系统中删除该消息队列，及其中的所有数据
 *        GETVAL    返回成员semnum的semval值
 *        SETVAL    设置成员semnum的semval值，由arg.val指定
 *        GETPID    返回成员semnum的sempid值
 *        GETNCNT   返回成员semnum的semncnt值
 *        GETZCNT   返回成员semnum的semzcnt值
 *        GETALL    获取集合中所有的信号量值，存储在arg.array中
 *        SETALL    使用arg.array中的值设置集合中所有的信号量
 * @arg   可选参数，定义如下
 * return 若成功 返回0；否则 返回-1
*/
int semctl(int semid, int semnum, int cmd, .../* union semun arg */);
union semun {
  int             val;      // for SETVAL
  struct semid_ds *buf;     // for IPC_STAT and IPC_GET
  unisigned short *array;   // for GETALL and SETALL
}

/**
 * 原子操作，增加或减少信号量值
 * @semid       信号量集合的内部标识符
 * @semoparray  信号量操作数组，具体结构如下
 * @nops        操作数组的长度
 * return       若成功 返回0；否则 返回-1
*/
int semop(int semid, struct sembuf semoparray[], size_t nops);
struct sembuf {
  unsigned short  sem_num;  // 信号量集合中的成员 (0, 1, ..., nsems-1)
  short           sem_op;   // 正值，表示要获取的资源数；负值，表示要释放的资源数；0，表示进程希望等待该信号量值为0
  short           sem_flg;  // IPC_NOWAIT, SEM_UNDO
}
```

结论就是，进程间同步推荐使用记录锁。信号量功能花哨，速度不高；互斥量速度最快，但是较复杂

##### 共享内存
